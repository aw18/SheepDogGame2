<!DOCTYPE html>
<html>
	<head>
        <!--SEE: https://discoverthreejs.com/book/first-steps/animation-loop/-->
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
			
            // initialize scene, camera, renderer
            const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            camera.position.z = 400;

            // spawn cones
            class Cone {
                constructor(){
                    this.is2D = true;
                    this.isPerceptionCircleVisible = false;

                    // ui
                    this.geometry = new THREE.ConeGeometry(3, 10, 32);
                    this.material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
                    this.cone = new THREE.Mesh( this.geometry, this.material );

                    // position
                    this.position = new THREE.Vector3(
                        this.randomMinMax(-1 * window.innerWidth, window.innerWidth), 
                        this.randomMinMax(-1 * window.innerHeight, window.innerHeight), 
                        this.is2D ? 0 : this.randomMinMax(-1 * window.innerHeight, window.innerHeight));
                    this.velocity = (new THREE.Vector3()).randomDirection();
                    this.acceleration = (new THREE.Vector3()).randomDirection();
                    this.maxForce = 0.02;
                    this.maxSpeed = 1;

                    if (this.is2D)
                    {
                        this.velocity.z = 0;
                        this.acceleration.z = 0;
                    }

                    // update ui with position value
                    this.cone.position.x = this.position.x;
                    this.cone.position.y = this.position.y;
                    this.cone.position.z = this.position.z;
                    this.cone.rotation.x = Math.random();
                    this.cone.rotation.y = Math.random();
                    this.cone.rotation.z = Math.random();

                    // draw circle around cone
                    this.perceptionRadius = 30;
                    if (this.isPerceptionCircleVisible)
                    {
                        this.circle = this.drawPerceptionCircle();
                    }
                }

                edges(){
                    if (this.position.x >= (window.innerWidth/2)){
                        this.position.x = -1 * (window.innerWidth/2);
                    }
                    else if (this.position.x < (-1 * (window.innerWidth/2))){
                        this.position.x = window.innerWidth/2;
                    }
                    if (this.position.y >= (window.innerHeight/2)){
                        this.position.y = -1 * (window.innerHeight/2);
                    }
                    else if (this.position.y < (-1 * (window.innerHeight/2))){
                        this.position.y = window.innerHeight/2;
                    }
                }

                drawPerceptionCircle(){
                    var geometry = new THREE.CircleGeometry( this.perceptionRadius, 32 );
                    var material = new THREE.MeshBasicMaterial( { color: 0x9A33FF } );
                    var circle = new THREE.LineLoop( geometry, material );
                    circle.position.set(
                        this.cone.position.x,
                        this.cone.position.y,
                        this.cone.position.z);
                    return circle;
                }

                updateConePos(){
                    this.cone.position.x = this.position.x;
                    this.cone.position.y = this.position.y;
                    this.cone.position.z = this.position.z;
                    this.cone.rotation.x += 0.01;
                    this.cone.rotation.y += 0.01;
                    this.cone.rotation.z += 0.01;

                    // draw circle around cone
                    if (this.isPerceptionCircleVisible)
                    {
                        this.circle.position.set(
                            this.cone.position.x,
                            this.cone.position.y,
                            this.cone.position.z);
                    }
                }

                update(){
                    this.position.add(this.velocity);
                    this.velocity.add(this.acceleration);
                    // this.velocity.clampLength(0, this.maxForce); ?????
                    this.updateConePos();
                    this.acceleration.multiplyScalar(0);
                }

                align(boids){
                    let steering = new THREE.Vector3();
                    let total = 0;
                    for (let other of boids){
                        let d = this.position.distanceTo(other.position);
                        if (other != this && d < this.perceptionRadius){
                            steering.add(other.velocity);
                            total++;
                        }
                    }

                    if (total > 0){
                        steering.divideScalar(total);
                        steering.setLength(this.maxSpeed);
                        steering.sub(this.velocity);
                        steering.clampLength(0, this.maxForce);
                    }

                    return steering;
                }

                cohesion(boids){
                    let steering = new THREE.Vector3();
                    let total = 0;
                    for (let other of boids){
                        let d = this.position.distanceTo(other.position);
                        if (other != this && d < this.perceptionRadius){
                            steering.add(other.position);
                            total++;
                        }
                    }

                    if (total > 0){
                        steering.divideScalar(total);
                        steering.sub(this.position);
                        steering.setLength(this.maxSpeed);
                        steering.sub(this.velocity);
                        steering.clampLength(0, this.maxForce);
                    }

                    return steering;
                }

                flock(boids){
                    let alignment = this.align(boids);
                    let cohesion1 = this.cohesion(boids);
                    this.acceleration.add(alignment);
                    this.acceleration.add(cohesion1);
                }

                randomMinMax(min, max){
                    return Math.random() * (max-min) + min;
                }
            } // end of Cone class

            // main logic
            var cones = [];
            for(let i = 0; i < 500; i++){
                var cone = new Cone();
                cones.push(cone);
                if (cone.isPerceptionCircleVisible)
                {
                    scene.add( cone.circle );
                }
                scene.add( cone.cone );
            }

			function animate() {
				requestAnimationFrame( animate );

                for (const c of cones){
                    c.edges();
                    c.flock(cones);
                    c.update();
                }

				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>